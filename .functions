#!/usr/bin/env bash

# change directory & list contents
function cdl {
  cd "$@" && ls
}

# create a new directory and enter it
function mkd {
  mkdir -p "$@" && cd "$@"
}

# find shorthand
# https://github.com/paulirish/dotfiles/blob/master/.functions
function f {
    find . -name "$1"
}

# cd into whatever is the forefront finder window.
function cdf {
    cd "`osascript -e 'tell app "Finder" to POSIX path of (insertion location as alias)'`"
}

# image width
function width {
  echo $(sips -g pixelWidth $1 | grep -oE "[[:digit:]]{1,}$")
}

# image height
function height {
  echo $(sips -g pixelHeight $1 | grep -oE "[[:digit:]]{1,}$")
}

# use git's colored diff when available
hash git &>/dev/null
if [ $? -eq 0 ]; then
  function diff {
    git diff --no-index --color-words "$@"
  }
fi

# create a data url from an image (works for other file types too, if you tweak
# the content-type afterwards)
function dataurl {
  echo "data:image/${1##*.};base64,$(openssl base64 -in "$1")" | tr -d '\n'
}

# start an http server from a directory, optionally specifying the port
function server {
  local port="${1:-8000}"
  # set the default content-type to `text/plain` instead of
  # `application/octet-stream`  and serve everything as utf-8 (although not
  # technically correct, this doesn't break anything for binary files)
  python -c $'import SimpleHTTPServer;\nmap = SimpleHTTPServer.SimpleHTTPRequestHandler.extensions_map;\nmap[""] = "text/plain";\nfor key, value in map.items():\n\tmap[key] = value + ";charset=UTF-8";\nSimpleHTTPServer.test();' "$port"
}

# get gzipped file size
function gz {
  echo "orig size (bytes): "
  cat "$1" | wc -c
  echo "gzipped size (bytes): "
  gzip -c "$1" | wc -c
}

# extract archives - use: extract <file>
# credits to http://dotfiles.org/~pseup/.bashrc
function extract {
  if [ -f $1 ] ; then
    case $1 in
      *.tar.bz2) tar xjf $1 ;;
      *.tar.gz) tar xzf $1 ;;
      *.bz2) bunzip2 $1 ;;
      *.rar) rar x $1 ;;
      *.gz) gunzip $1 ;;
      *.tar) tar xf $1 ;;
      *.tbz2) tar xjf $1 ;;
      *.tgz) tar xzf $1 ;;
      *.zip) unzip $1 ;;
      *.Z) uncompress $1 ;;
      *.7z) 7z x $1 ;;
      *) echo "'$1' cannot be extracted via extract()" ;;
    esac
  else
    echo "'$1' is not a valid file"
  fi
}

# test if http compression (rfc 2616 + sdch) is enabled for a given url.
# send a fake ua string for sites that sniff it instead of using the
# accept-encoding header. (looking at you, ajax.googleapis.com!)
function httpcompression {
  encoding="$(curl -LIs -H 'User-Agent: Mozilla/5 Gecko' -H 'Accept-Encoding: gzip,deflate,compress,sdch' "$1" | grep '^Content-Encoding:')" && echo "$1 is encoded using ${encoding#* }" || echo "$1 is not using any encoding"
}

# gzip-enabled `curl`
function gurl {
  curl -sH "Accept-Encoding: gzip" "$@" | gunzip
}

# all the dig info
function digga {
  dig +nocmd "$1" any +multiline +noall +answer
}

# escape utf-8 characters into their 3-byte format
function escape {
  printf "\\\x%s" $(printf "$@" | xxd -p -c1 -u)
  echo # newline
}

# decode \x{abcd}-style unicode escape sequences
function unidecode {
  perl -e "binmode(STDOUT, ':utf8'); print \"$@\""
  echo # newline
}

# get a character's unicode code point
function codepoint {
  perl -e "use utf8; print sprintf('U+%04X', ord(\"$@\"))"
  echo # newline
}

function todo {
  cd ~/.todo || return 1&& l=$(ls -1t|head -n1)&&t=$(date +%Y%m%d);
  [[ "$1" == "last" ]]&&cp $l $t;
  ${EDITOR:-vi} $t;
  cd -;
}

# convert a list of wav files to v0 mp3
function V0 {
  for filename; do
    lame -V0 "$filename" "${filename%.*}.mp3"
  done
}

# create a default .gitignore file for a project
function gitignore {
  curl https://gist.githubusercontent.com/axelav/e0c1ba180cb00bc62df2/raw/395dedef31dbc0f693ee1a922a522827dffccbed/.gitignore > .gitignore
}

# gitignore as a service: https://github.com/joeblau/gitignore.io
function gi {
  curl -L -s https://www.gitignore.io/api/$@;
}

function backup {
  rsync -avz --delete --progress --exclude-from "$HOME/.rsync_excludes" $HOME /Volumes/BigBoi;
  date >> /Volumes/BigBoi/BACKUP;
}
